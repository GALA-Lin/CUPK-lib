/*********************************************************************
程序名：打印质因数相乘
版权：遵从GPL版权协议，可自由使用和传播（请勿上传到收费性网络文库）
作者：anbangli@foxmail.com
日期：2019-07-21
说明：
5-5.定义函数：void prtPrimeDecomp(int n)，它对正整数实际参数先判断
是否质数，如果是质数就输出该数本身，如果是合数则分解成质因数相乘的
形式并输出（多重因子重复输出）。例如，对 12 就分解为 2 * 2 * 3。
对于负整数参数，首先输出 -1，然后按上述方法处理。
编写主函数对 -20 ~ 20的整数测试此函数。
*********************************************************************/
#include <iostream>
using namespace std;

//此题要用到质数判断。把教材正文中的 isprime 函数复制到这里。
int isprime(int n) {
	int k;

	if (n <= 1)
		return 0;	//这一句是教材正文补充的，也要写进来
	for (k = 2; k * k <= n; k++)
		if (n % k == 0)    //发现一个因数就足以判断不是质数
			return 0;
	return 1;  //上面循环中没有发现因数，所以判断是质数
}

void prtPrimeDecomp(int n) {	//定义函数时，参数表中要写参数名
//从题目要求来看，似乎应该先判断 n 是否为质数，如果是质数就输出该数本身并结束函数。
//然而并不需要这样做。下面的语句实际上包含了这一功能。

	cout << n << " = ";
	if (n < 0) {	//负数
		cout << "-1 * ";
		n = -n;	//负数转为正数处理
	}

	int k;
	//做循环，每次找到一个质因数并让 n 除以该质因数，直到 n 变为质数
	while (!isprime(n) && n > 1) {
		for (k = 2; k < n; k++) {
			if (isprime(k) && n % k == 0) {
				cout << k << " * ";
				break;	//找到一个质因数就结束内层循环
			}
		}
		n = n / k;	//n 除以上面循环所找到的质因数
	}
	cout << n << endl;	//此时 n 必为质数，直接输出
	return;
}

//另一种巧妙的写法，不需要使用质数判断
//void prtPrimeDecomp(int n) {
//	int k;
//	cout << n << " = ";
//	if (n < 0) {  //负数要转换为正数，并输出 "-1 * "
//		n = -1 * n;
//		cout << "-1 * ";
//	}
//	if (n <= 1)  // 0 和 1 直接输出
//		cout << n << endl;
//	//下面处理大于 1 的正数
//	for (k = 2; k <= n; k++) {
//		while (n % k == 0) {
//			n = n / k;
//			cout << k << ( n != 1 ? " * " : "\n");
//		}
//	}
//	return;
//}


int main() {

	cout << "把整数分解为质因数相乘" << endl;
	for (int n = -20; n <= 20; n++)
		prtPrimeDecomp(n);	//!!

	return 0;
}

