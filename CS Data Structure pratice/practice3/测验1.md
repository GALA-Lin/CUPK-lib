# 一. 简答题（共2题）

## 1. (简答题)根据文件内容，文件可分为文本文件和二进制文件。对两种文件访问有什么特点？文件为什么需要打开和关闭？或说文件打开和关闭的主要作用是什么？实现文件访问的主要流程是什么？有什么注意事项？

1. **文件类型：文本文件 vs 二进制文件**

- **文本文件：**

特点：文本文件存储的是经过编码的字符数据（如UTF-8/ASCII等）。可以使用文本编辑器直接查看和编辑。

访问特点：读取时会自动处理字符编码，适合存储人类可读信息，但会产生转换开销。例如，数字'123'会被存储为字符'1'、'2'、'3'。

- **二进制文件：**

特点：二进制文件存储的是原始的二进制数据，不进行编码转换，直接以二进制格式存储。

访问特点：读取时不进行编码转换，适合存储机器可读的数据（如图像、音频、视频、执行文件等），文件大小相对较小，但编辑起来较困难，需要专门软件。

2. **文件需要打开和关闭的原因**

- **文件打开的作用：**
  
  - 分配资源：操作系统需要为文件操作分配资源（内存空间、文件描述符等）。
  - 设置访问模式：确定是只读、只写、还是读写模式。
  - 进行缓冲设置：在文件打开时，可以设置缓存模式，提高读写性能。
- **文件关闭的作用：**
  
  - 释放资源：关闭文件会释放文件指针、文件描述符等资源，避免资源泄露。
  - 刷新缓冲区：确保所有缓冲区中的数据正确写回到文件中，防止数据丢失。
  - 更新文件元数据：操作系统会在关闭文件时更新相关的元数据，如文件修改时间等。

3. **实现文件访问的主要流程和注意事项**

- **主要流程：**
  
  - 打开文件：使用适当的函数（如fopen、open等）打开文件，获得文件指针或文件描述符。
  - 处理文件：根据需要进行读、写操作（如fread、fwrite、fgets、fputs等)。
  - 关闭文件：使用函数（如fclose、close等）关闭文件，释放资源。
- **注意事项：**
  
  - 错误处理：在每一步操作后都应该检查返回值，进行适当的错误处理。例如，文件是否成功打开、读写是否成功。
  - 避免资源泄露：确保文件打开后在所有可能退出的路径上都能够正确关闭文件。
  - 缓冲区管理：在对文件进行大量读写操作时，应该合理管理缓冲区，使用合适的缓冲区大小以提升效率。
  - 文件权限：打开文件时要注意文件权限设置（如w、r、a、b、w+、r+等），确保文件权限符合要求。
  - 编码问题：对于文本文件，需注意文件编码的选择和处理，防止乱码问题。

## 2. (简答题) 叙述树的路径求解过程depthSearch(start,end)（以深度优先为例，自己设计一棵树（逻辑结构），表述清楚路径的求解）。

我们将设计一棵简单的树作为示例，并解释如何通过深度优先搜索（DFS）来查找特定节点的路径。假设我们有以下树结构：

```
   A
  / \
 B   C
/ \   \
D   E   F
```

假如我们希望寻找从根节点A到目标节点E的路径。

**树结构：**

顶点A是根节点。

B和C是A的子节点。

D和E是B的子节点。

F是C的子节点。

**深度优先搜索（DFS）路径查找过程：**

在此过程中，我们会递归地检查每个节点，直到找到目标节点，并记录路径：

- 从根节点A开始，路径为[A]。
- 递归检查A的左子节点B，路径更新为[A, B]。
- 递归检查B的左子节点D，路径更新为[A, B, D]。
  
  - D不是目标节点，返回上一级。
- 递归检查B的右子节点E，路径更新为[A, B, E]。
  
  - E是目标节点，输出当前路径[A, B, E]。
- 递归检查A的右子节点C，路径更新为[A, C]。
  
  - C不是目标节点，继续检查。
- 递归检查C的右子节点F，路径更新为[A, C, F]。
  
  - F不是目标节点，返回上一级。

**depthSearch函数代码：**

```C/C++
void depthSearch(TreeNode *root, char *target, char path[][MAX_NAME_LEN], int pathIndex) {
    if (root == NULL) return;
    strcpy(path[pathIndex], root->name);
    if (strcmp(root->name, target) == 0) {
        for (int i = 0; i <= pathIndex; i++) {
            printf("%s ", path[i]);
        }
        printf("\n");
    }
    depthSearch(root->left, target, path, pathIndex + 1);
    depthSearch(root->right, target, path, pathIndex);
}
```

**其中：**

```C/C++
char path[n][MAX_NAME_LEN];
memset(path, 0, sizeof(path)); // 初始化路径数组
```

1. TreeNode *start是一个指向起始节点的指针，表示当前递归搜索的起点节点。类型是 TreeNode *，即指向树节点的指针。
2. char *end是一个字符串指针，表示要查找的目标节点的名字。类型是 char *，即指向字符（字符串）的指针。
3. char path[][MAX_NAME_LEN]是一个二维字符数组，表示查找路径中的节点名字。类型是 char path[][MAX_NAME_LEN]，其中MAX_NAME_LEN是宏定义，用于限定名字的最大长度。
4. int pathIndex这是一个整数，表示当前路径的索引（或深度）。随着递归深度的增加，该索引也相应增加，用于在路径数组 path中正确地存放节点名字。

